!sched_interactive should also try to preempt the current CPU first provided the
cpu matches avoiding need to check locality_diff.

-ck

---
 kernel/sched/bfs.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

Index: linux-4.7-ck5/kernel/sched/bfs.c
===================================================================
--- linux-4.7-ck5.orig/kernel/sched/bfs.c	2016-09-23 08:32:58.241736888 +1000
+++ linux-4.7-ck5/kernel/sched/bfs.c	2016-09-23 08:32:58.239736900 +1000
@@ -1475,7 +1475,7 @@ static void try_preempt(struct task_stru
 
 	/* See if this task can preempt the task on the current CPU first. */
 	pcpu = cpu_of(this_rq);
-	if (!sched_interactive && cpumask_test_cpu(pcpu, &tmp)) {
+	if (likely(cpumask_test_cpu(pcpu, &tmp))) {
 		if (smt_schedule(p, this_rq) && can_preempt(p, this_rq->rq_prio, this_rq->rq_deadline)) {
 			resched_curr(this_rq);
 			return;
